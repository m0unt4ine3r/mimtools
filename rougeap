#!/bin/python

# TODO:
# redo with less shell
# - add more functions
# - replace % with format() where possible
# - macchanger!!!

import io
import os
import re
import sys
import time
import getopt
import curses
import subprocess

# because colors are important
curses.use_default_colors()

# path to user configs
# if statement?
path = '%s/.config' % os.path.expanduser('~')
#path = 'config'	# for testing git

# get ap conf
with open('{}/hostapd/rouge.conf'.format(path), 'r') as apconffile:
	apconf = apconffile.read()

# dns conf
#with open('{}/dnsmasq/rouge.conf'.format(path), 'r') as dnsconffile:
#	dnsconf = dnsconffile.read()

# log files
dlog = 'dnsmasq.log'
hlog = 'hostapd.log'

# default access point vars - redo with python regex
apdev = re.search('interface=(.*)', apconf).group(1)
apsubnet = '10.0.0.0'
apnetmask = '255.255.255.0'
apip = '10.0.0.1/24'

# ap settings - redo with python regex
ssid = re.search('ssid=(.*)', apconf).group(1)
chan = re.search('channel=(.*)', apconf).group(1)
enc = re.search('auth_algs=(.*)', apconf).group(1)
password = re.search('wpa_passphrase=(.*)', apconf).group(1)

# default internet device vars
codev = 'wlp3s0'
coip = subprocess.Popen("ip a | grep %s | awk 'FNR==2 {print $2}'" % codev, shell=True,
		stdout=subprocess.PIPE, universal_newlines=True).communicate()[0].strip()

# all detected devices
devices = subprocess.Popen("ip a | grep \^\[0-9\] | awk '{print $2}' | cut -d':' -f1", shell=True,
		stdout=subprocess.PIPE, universal_newlines=True).communicate()[0].strip().split()

# ----------

# Curses input prompt
def cursin(stdscr, prompt):
	arr = []
	word = ''
	pos = size = 0

	while True:
		try:
			stdscr.addstr(prompt)
			stdscr.addstr(word)
			stdscr.move(0, pos)
			stdscr.refresh()
			key = stdscr.getkey()

			if key == '\n':
				return word

			elif str(key) == 'KEY_BACKSPACE':
				if pos > 0:
					arr.pop(pos-1)
					size -= 1
					pos -= 1

				else:
					pass

			elif str(key) == 'KEY_LEFT':
				if pos > 0:
					pos -= 1

				else:
					pass

			elif str(key) == 'KEY_RIGHT':
				if pos < size:
					pos += 1

				else:
					pass

			elif ord(key) >= 32 or ord(key) <= 126:
				stdscr.clear()
				arr.insert(pos, key)
				size += 1
				pos += 1

			word = ''.join(arr)

		except TypeError:
			pass

		except KeyboardInterrupt:
			curses.endwin()
			print('Exiting...')
			break

# ----------

def menu(stdscr):
	while True:
		try:
			stdscr.clear()
			stdscr.addstr('[Menu splash here]\n')
			stdscr.addstr('0 - Exit\n')
			stdscr.addstr('1 - AP setup\n')
			stdscr.addstr('2 - IP setup\n')
			stdscr.addstr('3 - Start AP\n')
			selection = int(cursin(stdscr, '> '))
			#selection = int(input('> '))

			if selection == 0:
				sys.exit(0)

			elif selection == 1:
				os.system('clear')
				#varsetup()
				break

			elif selection == 2:
				os.system('clear')
				stdscr.addstr('Coming soon')
				break

			elif selection == 3:
				os.system('clear')
				#apstart()
				break

			else:
				os.system('clear')
				stdscr.addstr('Number out of range.')

#		except ValueError:
#			os.system('clear')
#			stdscr.addstr('Invalid input.')

		except KeyboardInterrupt:
			stdscr.addstr('\nExiting...')
			sys.exit(0)

#		except Exception as e:
#			stdscr.addstr('\nError: {}'.format(e))
#			stdscr.addstr('Exiting...')
#			sys.exit(1)

# ----------

def varsetup():
	try:
		# globals
		global apdev
		global ssid
		global chan
		global enc
		global password

		while True:
			# set device to be used as ap
			defap = apdev

			while True:
				stdscr.addstr('Detected devices:')
				i = 0

				for d in devices:
					stdscr.addstr('{} - {}'.format(i, d))
					i += 1

				apselect = input('# of dev to be used as AP [{}]: '.format(defap))
				
				try:
					apselect = int(apselect)

				except ValueError:
					os.system('clear')
					stdscr.addstr('Invalid input.')
					continue

				if apselect and devices[apselect] != apdev:
					if apselect in range(i):
						os.system('clear')
						apdev = devices[apselect]
						confirm = input('New AP dev is: {}\nIs this correct? [y/N]: '.format(apdev)).lower()

						if confirm == 'y':
							os.system('clear')
							break

					elif  apselect not in range(i):
						os.system('clear')
						stdscr.addstr('Not a valid selection.')

				else:
					os.system('clear')
					confirm = input('Leave AP dev as default ({})? [y/N]: '.format(defap)).lower()

					if confirm == 'y':
						os.system('clear')
						break

			# set ssid
			defssid = ssid
			while True:
				ssidselect = input('Enter SSID [{}]: '.format(defssid))

				if ssidselect and ssidselect != ssid:
					ssid = ssidselect
					os.system('clear')
					confirm = input('New SSID is: {}\nIs this correct? [y/N]: '.format(ssid)).lower()

					if confirm == 'y':
						os.system('clear')
						break

				else:
					#
					# - maybe change to "Leave SSID as default (default)? [y/N]: "
					#
					os.system('clear')
					confirm = input('Leave SSID as default ({})?'.format(defssid)).lower()

					if confirm == 'y':
						os.system('clear')
						break

			# set channel
			defchan = chan
			while True:
				chanselect = input('Select a channel [{}]: '.format(defchan))

				if chanselect:
					try:
						chanselect = int(chanselect)

					except ValueError:
						os.system('clear')
						stdscr.addstr('Invalid input.')
						continue

					if chanselect in range(1, 12):
						chan = chanselect
						os.system('clear')
						confirm = input('New channel is: {}\nIs this correct? [y/N]: '.format(chan)).lower()

						if confirm == 'y':
							os.system('clear')
							break

						else:
							continue

					else:
						os.system('clear')
						stdscr.addstr('Invalid input. Valid channels (for US) are 1-12.')
						continue

				else:
					os.system('clear')
					stdscr.addstr('Channel remains "{}".'.format(defchan))
					break
			
			# set encryption
			defenc = enc
			modes = ('open', 'wpa2', 'wep')

			while True:
				stdscr.addstr('Encryption modes:')
				stdscr.addstr('0 - open')
				stdscr.addstr('1 - wpa2')
				stdscr.addstr('2 - wep')
				encselect = int(input('Select encryption type [{}]: '.format(defenc)))

				if encselect:
					try:
						encselect = int(encselect)

					except ValueError:
						os.system('clear')
						stdscr.addstr('Invalid input.')
						continue

					if encselect in range(3):
						enc = encselect
						os.system('clear')
						confirm = input('New encryption type is "{}". Is this correct? [y/N]: '.format(modes[enc])).lower()

						if confirm == 'y':
							break

					elif not encselect:
						os.system('clear')
						stdscr.addstr('Encrytption mode remains "{}".'.format(modes[enc]))
						break

				#
				# - ADD PASSWORD!!! and fix wiping/make tui
				#

				# final confirm and commit
				os.system('clear')
				stdscr.addstr('--Final settings--')
				stdscr.addstr('AP interface:\t\t{}'.format(apdev))	# tab alignment???
				stdscr.addstr('SSID:\t\t\t{}'.format(ssid))
				stdscr.addstr('Channel:\t\t{}'.format(chan))
				stdscr.addstr('Encryption mode:\t{}'.format(modes[int(enc)]))
				finalselect = input('Are these settings correct? [y/N]: ').lower()

				if finalselect == 'y':
					break

			stdscr.addstr('Commiting...')
			commit()
			break

	except KeyboardInterrupt:
		stdscr.addstr('\nExiting...')
		sys.exit(0)

	except Exception as e:
		stdscr.addstr('\nError: {}'.format(e))
		stdscr.addstr('Exiting...')
		sys.exit(1)

# ----------

def commit():
	global apconf
	global apdev
	global ssid
	global chan
	global enc

	# make file changes here
	apconf = re.sub('(interface=).*', '\g<1>{}'.format(apdev), apconf)
	apconf = re.sub('(ssid=).*', '\g<1>{}'.format(ssid), apconf)
	apconf = re.sub('(channel=).*', '\g<1>{}'.format(chan), apconf)
	apconf = re.sub('(auth_algs=).*', '\g<1>{}'.format(enc), apconf)

	print(apconf)
	
	with open('{}/hostapd/rouge.conf'.format(path), 'w') as apconffile:
		apconffile.write(apconf)

# ----------

def apstart():
	try:
		# Configure iface
		subprocess.run('ip link set %s down' % apdev, shell=True, check=True)
		subprocess.run('ip addr flush dev %s' % apdev, shell=True, check=True)
		subprocess.run('ip link set %s up' % apdev, shell=True, check=True)
		subprocess.run('ip addr add %s dev %s' % (apip, apdev), shell=True, check=True)

		# Set up NAT
		subprocess.run('iptreset', shell=True, check=True)
		subprocess.run('iptables -t nat -A POSTROUTING -o %s -j MASQUERADE' % codev, shell=True, check=True)
		subprocess.run('iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT', shell=True, check=True)
		subprocess.run('iptables -A FORWARD -i %s -o %s -j ACCEPT' % (apdev, codev), shell=True, check=True)
		subprocess.run('sysctl -w net.ipv4.ip_forward=1', shell=True, check=True)

		# Stop dnsmasq if started
		dnsmasq = subprocess.Popen('ps -e | grep dnsmasq', shell=True, stdout=subprocess.PIPE,
					universal_newlines=True).communicate()[0].strip()

		if dnsmasq:
			print('dnsmasq already running. Kill it? [y/N]')
			killit = input('> ').lower()
		
			if killit != 'y':
				sys.exit('Exiting program')

			subprocess.run('killall dnsmasq', shell=True)

		# Start dsnmasq and hostapd
#		dwriter = io.open(dlog, 'wb') 
#		dreader = io.open(dlog, 'rb', 1)
#		hwriter = io.open(hlog, 'wb') 
#		hreader = io.open(hlog, 'rb', 1)

		with io.open(dlog, 'wb') as dwriter, io.open(hlog, 'wb') as hwriter,\
			io.open(dlog, 'rb', 1) as dreader, io.open(hlog, 'rb', 1) as hreader:
			dnsmasq = subprocess.Popen('dnsmasq -d -C %s/dnsmasq/rouge.conf' % path, shell=True,
						stdout=dwriter, universal_newlines=True)
			hostapd = subprocess.Popen('hostapd %s/hostapd/rouge.conf' % path, shell=True,
						stdout=hwriter, universal_newlines=True)

			while dnsmasq.poll() is None and hostapd.poll() is None:
				dout = dreader.read().decode()
				hout = hreader.read().decode().strip()

				if dout:
					print(dout)

				if hout:
					print(hout)

#		while True:
#			if hreader.read().decode():
#				print('From hostapd: ' + hreader.read().decode())
#				#sys.stdout.write('From hostapd: ' + hreader.read().decode())
#			if dreader.read().decode():
#				print('dnsmasq')
#				print('From dnsmasq: ' + dreader.read().decode())
#				#sys.stdout.write('From dnsmasq: ' + dreader.read().decode())
			
	except KeyboardInterrupt:
		code = 0
		pass

	except Exception as error:
		code = 1
		print('Error: {}.'.format(error))

	# Tear everything down
	print('Stopping hostapd...')
	hostapd.terminate()
	print('Stopping dnsmask...')
	dnsmasq.terminate()
	print('Stopping ip forwarding...')
	subprocess.run('sysctl -w net.ipv4.ip_forward=0', shell=True, check=True)
	print('Resetting iptables...')
	subprocess.run('iptreset', shell=True, check=True)
	print('Removing log files...')
	os.remove(hlog)
	os.remove(dlog)
	sys.exit(code)

# ----------

if __name__ == '__main__':
	os.system('clear')
	if os.getuid() != 0:	# needs to be changed to only get root when needed and drop back to userland
		print('This script needs root.')
		os.execvp('sudo', ['sudo', '-E'] + sys.argv)

	curses.wrapper(menu)
#	varsetup()
#	apsetup()
